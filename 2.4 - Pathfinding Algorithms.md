# Pathfinding Algorithms

## Dijkstra's Algorithm (Adapted from [Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), [GIF](assets/Dijkstra.gif))

> Finds the shortest path from a start node to a goal node.

1. Assign every node a tentative distance value. Zero for the start node and infinity for all other nodes.
2. Set the start node as current. Mark all other nodes unvisited. Create a set of all the unvisited nodes.
3. For the current node, consider all of its neighbors and calculate their tentative distances. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one. If the newly calculated tentative distance is smaller, assign the current node as the neighbor's previous node.
4. When we are done considering all of the neighbors of the current node, mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again.
5. If there are still unvisited nodes, select an unvisited node with the smallest tentative distance, set it as the new "current node" and go back to Step 3.
6. Use the goal's previous node to recursively backtrack to the start node.

```java
HashMap<Node, Node> Dijkstra(Node[] graph, Node start, Node goal) {
    HashMap<Node, Integer> dist = new HashMap<>();
    HashMap<Node, Node> prev = new HashMap<>();

    PriorityQueue queue = PriorityQueue(graph, dist);  // Queue that stores nodes in ascending order of distance
    for (Node n : graph) {
        if (n != start) {
            dist.put(n, INTEGER.MAX_VALUE);
            prev.put(n, null);
        }
        queue.add(n);
    }
    dist.put(start, 0);

    while (!queue.isEmpty()) {
        Node current = queue.getMinimum();  // Get minimum distance node
        if (current == goal) return prev;

        for (Node neighbor : current.neighbors) {
            int altDistance = dist.get(current) + distance(current, neighbor);
            if (altDistance < dist.get(neighbor)) {
                dist.put(neighbor, altDistance);
                prev.put(neighbor, current);
                queue.updatePriority(neighbor);  // Update position of node in queue
            }
        }
    }

    return null;  // No path found!
}
```

### Time Complexity

- Each node `V` can be adjacent to a maximum `|V - 1|` vertices.
- Finding and updating the weight of each adjacent node in a binary heap is `O(log |V|)`.
- Therefore, updating all the adjacent vertices of one node is `O(|V - 1| log |V|)`.
- Hence, time complexity for updating for all vertices is `O(|V| |V - 1| log |V|)`, which can be simplified to:

```
O(|E| log |V|)
```

where `|E|` represents the total number of edges in the graph.

## A* Search Algorithm (Adapted from [Wikipedia](https://en.wikipedia.org/wiki/A*_search_algorithm))

> Finds the shortest path from a start node to a goal node.

The A* search algorithm is based on minimizing:

```
f(n) = g(n) + h(n)
```

where `f(n)` is the estimated distance of `START` to `GOAL` through `n`, `g(n)` is the known distance from `START` to `n` and `h(n)` is the heuristic distance from `n` to `GOAL`.

The heuristic must follow the the triangle inequality theorem i.e. `|h(A) - h(b)| â‰¤ dist(A, B)` for all vertices `A, B`.

> Dijkstra's algorithm is a special case of A*, where h(n) = 0.

```java
HashMap<Node, Node> A*(Node[] graph, Node start, Node goal) {
    HashSet<Node> openSet = new HashSet<>();
    HashSet<Node> closedSet = new HashSet<>();

    openSet.add(start)

    HashMap<Node, Node> prev = new HashMap<>();
    HashMap<Node, Integer> gScore = new HashMap<>();
    HashMap<Node, Integer> fScore = new HashMap<>();

    for (Node n : graph) {
        gScore.put(n, Integer.MAX_VALUE);
        fScore.put(n, Integer.MAX_VALUE);
    }

    gScore.put(start, 0)
    fScore.put(start, heuristicEstimate(start, goal))

    while (!openSet.isEmpty()) {
        Node current = openSet.getMinimum();  // Get node with lowest fScore value
        if (current == goal) return prev;

        openSet.remove(current);
        closedSet.add(current);

        for (Node neighbor : current.neighbors) {
            if (closedSet.contains(neighbor)) continue;
            if (!openSet.contains(neighbor)) openSet.add(neighbor);

            int altGScore = gScore.get(current) + distance(current, neighbor);
            if (altGScore < gScore.get(neighbor)) {
                prev.put(neighbor, current);
                gScore.put(neighbor, altGScore);
                fScore.put(neighbor, altGScore + heuristicEstimate(neighbor, goal));
            }
        }
    }

    return null;  // No path found!
}
```

### Time Complexity

Since A* algorithm's runtime complexity is heavily dependent on the heuristic chosen, the worst case time complexity for an unbounded search space is:

```
O(b^d)
```

where `b` is the branching factor (i.e. average number of successors per state) and `d` is the depth of the solution.

## Bellman-Ford Algorithm (Adapted from [Wikipedia](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm))

> Finds the shortest path from a single source node to all the other nodes in the graph. If there is a negative weight cycle, then the shortest distances are not calculated and the cycle is reported.

1. Initialize distance for all nodes as infinite, except the source node, which is initialized as zero.
2. Repeat the following `|V| - 1` times:
    1. For each edge `u, v`, if `dist[v] > dist[u] + weight(u, v)`, then `dist[v] = dist[u] + weight(u, v)`.
3. Repeat the following for each edge `u, v`:
    1. If `dist[v] > ist[u] + weight(u, v)`, graph contains a negative weight cycle.

- Step 3 is performed because Step 2 guarantees shortest distances only if the graph doesn't contain a negative weight cycle.
- Unlike Dijkstra's algorithm, Bellman-Ford is capable of handling graphs with *some* negative weight edges.

```java
int[] BellmanFord(Graph graph, int src) {
    int V = graph.V;  // number of vertices
    int E = graph.E;  // number of edges
    int[] dist = new int[V];  // distances to nodes

    for (int i = 0; i < V; i++) dist[i] = Integer.MAX_VALUE;
    dist[src] = 0;

    for (int i = 1; i < V; i++) {
        for (int j = 0; j < E; j++) {
            int u = graph.edge[j].src;
            int v = graph.edge[j].dest;
            int weight = graph.edge[j].weight;
            if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v])
                dist[v] = dist[u] + weight;
        }
    }

    for (int j = 0; j < E; j++) {
        int u = graph.edge[j].src;
        int v = graph.edge[j].dest;
        int weight = graph.edge[j].weight;
        if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v])
          System.out.println("Graph contains negative weight cycle.");
    }

    return dist;
}
```

### Time Complexity

```
O(|V| |E|)
```

## Floyd-Warshall Algorithm (Adapted from [Wikipedia](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm))

> Finds the shortest paths between all pairs of nodes in a graph with no negative weight cycles.

1. Initialize the solution matrix as the same as the input graph matrix i.e. the shortest paths are initialized as the paths with no intermediate nodes.
2. For every vertex `k`, consider it as the intermediate node for a path between `u` & `v`. Then, either:
    1. `k` is not an intermediate vertex in shortest path from `u` to `v` and the value of `dist[u][v]` is kept as it is.
    2. `k` is an intermediate vertex in the shortest path from `u` to `v` and the value of `dist[u][v]` is updated to `dist[u][k] + dist[k][v]`.

```java
int[][] FloydWarshall(int graph[][]) {
    int[][] dist = new int[V][V];
    int i, j, k;

    for (i = 0; i < V; i++)
        for (j = 0; j < V; j++)
            dist[i][j] = graph[i][j];

    for (k = 0; k < V; k++) {
        for (u = 0; u < V; u++) {
            for (v = 0; v < V; v++) {
                if (dist[u][k] + dist[k][v] < dist[u][v])
                    dist[u][v] = dist[u][k] + dist[k][v];
            }
        }
    }

    return dist;
}
```

### Time Complexity

```
O(|V|^3)
```
